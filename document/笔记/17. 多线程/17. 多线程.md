#### 一、 多线程的概念
 
>进程:

* 狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。
* 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

>线程:

* 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。
* 线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。
* 同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。
* 一个进程可以有很多线程，每条线程并行执行不同的任务。

> 多线程：

* 多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。

> 多任务：

* 多任务处理是指用户可以在同一时间内运行多个应用程序,每个应用程序被称作一个任务.Linux、windows就是支持多任务的操作系统,比起单任务系统它的功能增强了许多。
* 当多任务操作系统使用某种任务调度策略允许两个或更多进程并发共享一个处理器时，事实上处理器在某一时刻只会给一件任务提供服务。因为任务调度机制保证不同任务之间的切换速度十分迅速，因此给人多个任务同时运行的错觉。多任务系统中有3个功能单位：任务、进程和线程。

#### 二、 iOS中的常见多线程方案

| 技术方案 |  简介| 语言 | 线程生命周期 | 使用频率 |
| --- | --- | --- | --- | --- |
| pthread | 一套通用的多线程API<br>适用于Unix\Linux\Windows等系统<br>跨平台\可移植<br>使用难度大|C|使用者管理|几乎不用|
|NSThread  | 使用更加面向对象<br>简单易用，可直接操作线程对象| OC | 使用者管理|偶尔使用|
| GCD |旨在替代NSThread等线程技术<br>充分利用设备的多核|C|自动管理|<table><tr><td bgcolor=red>经常使用</td></tr></table>|
| NSOperation |基于GCD（底层是GCD）<br>比GCD多了一些更简单实用的功能<br>使用更加面向对象|OC|自动管理|<table><tr><td bgcolor=red>经常使用</td></tr></table>|


#### 三、 GCD

#### 3.1 GCD的常用函数
*  用同步的方式执行任务
<br>dispatch\_sync(dispatch\_queue_t queue, dispatch\_block\_t block);
<br>queue：队列
<br>block：任务

* 用异步的方式执行任务
<br>dispatch\_async(dispatch\_queue\_t queue, dispatch\_block\_t block);


#### 3.2 GCD的队列可以分为2大类型
* 并发队列（Concurrent Dispatch Queue）
<br>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）
<br>并发功能只有在异步（dispatch\_async）函数下才有效

* 串行队列（Serial Dispatch Queue）
<br>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）

* dispatch\_queue\_t queue = dispatch\_get\_global\_queue(0, 0);
<br> 全局并发队列

```
- (void)gcd_global_queue_sync {
    ///全局并发队列:允许多个任务并发执行，并发在异步函数下才有效！！！
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///主线程中：任务1执行完之后任务2再执行
}
```

```
- (void)gcd_global_queue_async {
    ///全局并发队列:允许多个任务并发执行，并发在异步函数下才有效！！！
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///子线程中：任务1和任务2交替执行
}


```
* dispatch\_queue\_create(const char *\_Nullable label,
		dispatch\_queue\_attr\_t \_Nullable attr)
<br> attr: DISPATCH\_QUEUE\_SERIAL(串行队列)、DISPATCH\_QUEUE\_CONCURRENT（并发队列）
		
```
    ///DISPATCH_QUEUE_SERIAL or a NULL attribute invoke blocks serially in FIFO order
    ///DISPATCH_QUEUE_CONCURRENT attribute may invoke blocks concurrently
    dispatch_queue_t queue = dispatch_queue_create("com.bitatuto.cxt", DISPATCH_QUEUE_SERIAL);
```

```
- (void)queue_create_serial_async {
    
    ///DISPATCH_QUEUE_SERIAL or a NULL attribute invoke blocks serially in FIFO order
    ///DISPATCH_QUEUE_CONCURRENT attribute may invoke blocks concurrently
    dispatch_queue_t queue = dispatch_queue_create("com.bitatuto.cxt", DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///子线程中：任务1执行完之后执行任务2
}

```

```
- (void)queue_create_serial_sync {
    
    ///DISPATCH_QUEUE_SERIAL or a NULL attribute invoke blocks serially in FIFO order
    ///DISPATCH_QUEUE_CONCURRENT attribute may invoke blocks concurrently
    dispatch_queue_t queue = dispatch_queue_create("com.bitatuto.cxt", DISPATCH_QUEUE_SERIAL);
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///主线程中：任务1执行完之后执行任务2
}


```


```
- (void)queue_create_concurrent_async {
    
    ///DISPATCH_QUEUE_SERIAL or a NULL attribute invoke blocks serially in FIFO order
    ///DISPATCH_QUEUE_CONCURRENT attribute may invoke blocks concurrently
    dispatch_queue_t queue = dispatch_queue_create("com.bitatuto.cxt", DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///子线程中：任务1和任务2交替执行
}

```

```
- (void)queue_create_concurrent_sync {
    
    ///DISPATCH_QUEUE_SERIAL or a NULL attribute invoke blocks serially in FIFO order
    ///DISPATCH_QUEUE_CONCURRENT attribute may invoke blocks concurrently
    dispatch_queue_t queue = dispatch_queue_create("com.bitatuto.cxt", DISPATCH_QUEUE_CONCURRENT);
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///主线程中：任务1执行完之后执行任务2，并发只在异步函数下才有效
}

```

* dispatch_get_main_queue()
<br>串行主队列

```
- (void)gcd_main_queue_sync_crash {
    
    ///串行主队列:任务在主线程执行，主队列添加同步任务会死锁！！！
    dispatch_queue_t queue = dispatch_get_main_queue();
    dispatch_sync(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
}

```
```
- (void)gcd_main_queue_async {
    
    ///串行主队列:任务在主线程执行，主队列添加同步任务会死锁！！！
    dispatch_queue_t queue = dispatch_get_main_queue();
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务1：index = %d %@",i,[NSThread currentThread]);
        }
    });
    
    dispatch_async(queue, ^{
        for (int i = 0; i < 10; i++) {
            NSLog(@"任务2：index = %d %@",i,[NSThread currentThread]);
        }
    });
    ///主线程中：任务1执行完之后执行任务2
}

```













