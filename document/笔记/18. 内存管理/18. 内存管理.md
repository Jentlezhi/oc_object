#### 一、 CADisplayLink、NSTimer使用注意
 
> CADisplayLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用

* 解决方案

1.使用block

```
    __weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {
        [weakSelf timerTest];
    }];

```

2.使用代理对象（NSProxy）

```
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[JTProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];
    
    self.link = [CADisplayLink displayLinkWithTarget:[JTProxy proxyWithTarget:self] selector:@selector(linkTest)];
    [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];

```

```
#import "JTProxy.h"

@interface JTProxy ()

/// delegate
@property(weak, nonatomic) id delegate;

@end

@implementation JTProxy

+ (instancetype)proxyWithTarget:(id)target {
    
    JTProxy *proxy = [[JTProxy alloc] init];
    ///一定是弱引用
    proxy.delegate = target;
    return proxy;
}

///消息转发
- (id)forwardingTargetForSelector:(SEL)aSelector {
    
    return _delegate;
}

- (void)forwardInvocation:(NSInvocation *)anInvocation {
    
    [anInvocation invokeWithTarget:_delegate];
}

@end

```


